TENSOR HEAVEN - Tenh (pronounced "tench", similar to hyperbolic tangent tanh)

NOTES
- all library code is in tenh/
  * ideally there will be few/no cpp files
- only the root directory (the directory containing tenh/) should be included, in the same manner as Eigen.
- all test code is in tensorhell/ -- there are currectly ad-hoc tests/prototype code (e.g. eigen_interop_prototype.cpp
  and contraction_prototype.cpp), but the "real" tests are in the standard/ subdirectory.  the CMakeLists.txt file
  in the tensorhell/ subdirectory will build all of these.  the executable name for the "real" tests is "test".
- the "actual" tensor lib prototype code is in test/contraction_prototype.cpp
- some prototype code for strongly-typed vectors (which distinguish prime/dual spaces and "named" spaces)
  is in tensorhell/strongly_typed_vector_prototype.cpp

current goals:
- more frontends for Eigen functionality -- LDLT, QR, linear solve, etc
- strong typing for vectors -- named vector spaces (including "Generic") and prime/dual distinction (including self-dual)
  * default values should be "Generic" vector space ID and self-dual
  * canonical isomorphism for tensor2 -> vector will need to take into account basis
  * canonical isomorphism for vector -> scalar will need to take into account basis (a 1-dimensional vector space always has a
    canonical "unit" basis element which is the real number 1 (?))
  * template <typename Scalar, Uint32 DIM, typename VectorSpaceId, typename BasisId> struct Vector_t (NO default values)
  * VectorSpaceId should have the Dual space type (can specify self-dual here), and a static type_as_string method
  * BasisId should just be a "name" (a type, e.g. struct DiagonalizedBasis)
  * There should be a generic vector space type -- EuclideanSpace (?)
  * There should be a generic basis type -- StandardBasis (?) -- where the inner product is the identity
- column/row/block extraction/addressing
  * something like a(i|c(2)), where i is a TypedIndex_t<Vector,'i'> and c is an Index_t<Vector>
  * will need to somehow distinguish the type of i|c(2) from something like i|j, because a(i|c(2)) is an
    expression template with a particular fixed index plugged in.
- implement inner products and so forth using Tensor_i.
  this regularizes the implementation and relates to metrics/inner products
  * contractions will "request" the pairing, and if the type exists, the contraction works
    this would allow more flexibility in contractions (e.g. contracting a vector space V with itself via an inner product).
- isometric embedding for various types (e.g. Tensor2Symmetric_t, Tensor2Antisymmetric_t, so that SVD and other
  stuff can be used on them meaningfully, as the SVD and so forth depends on the metric of the relevant space,
  and the way Tensor2Symmetric_t is implemented does not use an isometric representation).
  * the isometric embedding should be the square root of the inner product.

future goals:
- a rigorous test suite, using Lvd test code -- it can handle everything up through seg faults -- and negative compile
  tests implemented at the build level, so that particular intentional compile errors can be verified to work.
- standard in-line linear algebra notation
  * for example, if A is a matrix and v is a vector, "A*v" should be equivalent to "A(i|j)*v(j)", but obviously
    without the need to use an indexed expression.
- optimize evaluation algorithm (ordering operations to do the minimal amount of computation)
- vectorizing as many operations as possible (in cooperation with loop-unrolling?)
- template specializations for particular tensor contractions for speed (using mathematical special cases)
  * for example, an antisymmetric 3x3 2-tensor contracted with a 3-vector is just a cross product
  * a diagonal 2-tensor contracted with a vector is just component-wise scaling
- in strongly typed vector template identifier types, require certain tags (e.g. static member constants)
  in the template parameters -- vector space identifier, vector space basis, etc.
- certain linear algebraic expressions simplify greatly when expressed in a particular basis,
  so having a formal mechanism to work with explicit bases may clarify and simplify some calculations

random TODOs:
- implement [anti]symmetric contiguous_index_to_rowcol_index as a lookup table for speed.
- allow use of same indices across different terms (distinguishing multiplication and addition)
- see if it's possible to do strong range check guarantees for indices (Index_t) -- this would probably
  require a "for each" construct which would best be accomplished with lambda expressions
- rename source files to use capitalized names (e.g. NaturalPairing.hpp) (?)
- it would probably be a good idea to make separate Vector_i and VectorSpace_i interfaces, and Tensor_i and TensorSpace_i
  interfaces -- VectorSpace_i and TensorSpace_i essentially just encode mathematical information and have no "implementation",
  whereas Vector_i and Tensor_i represent actual elements of a vector or tensor space.  then Vector_i and Tensor_i
  would take template parameters which are of types VectorSpace_i and TensorSpace_i respectively.
  this seems necessary in order to implement vector and tensor "constants", which don't represent a vector space,
  but actually a single element in a vector space.
- move "private" utility functions/metafunctions into the "Tenh::NonPublic" namespace so that they're not in the
  "Tenh" namespace, for at least a little bit of non-public interface hiding.
- make a nonpublic directory and put all NonPublic code in there (and actually put appropriate stuff in NonPublic namespace)
- allow 0-dimensional vector spaces (otherwise certain induced types (e.g. antisymmetric 2-tensors) will cause static asserts)
- use -Wno-tautological-compare for clang builds
- is it possible to specify the default value for Derived directly?
- make various tensor types check the IS_XYZ values for their template parameters
- see if some sort of static_cast can be used to detect if a type inherts a class, and use this to replace
  IS_EXPRESSION_TEMPLATE, IS_TENSOR2_T, etc.  Or failing that, use some template metafunction for this.
- make a STATIC_ASSERT_TYPES_ARE_EQUAL for convenience

features necessary for version 0.5:
x euclidean embedding (using short-term zero-dimensional hack (?))
x eval (for 2-tensors)
x basis specification (e.g. in diagonalization/SVD, and the orthonormal matrix could/should be called "basis vectors")
- provide a way to "name" the basis for diagonalization/SVD/etc
x stub-out: noalias (?) for situations like a(i) = a(i) + b(i), but also to avoid the runtime check of aliasing, so the human
  can specify no-alias in a situation like a(i) = b(i) + c(i).
- additional eigen interop:
  * 2-tensor inverse
  * LDLT
  * non-self-adjoint eigensolve
  * LU

basis considerations for strongly typed vector edition:
- several choices for bases on induced tensor products exist
  * "normalized" where square roots of multiplicities occur in both vector space and dual
    which is a "safe" compromise in the sense that it is uniform between vector space and dual
    but has the lowest component-to-actual-memory-location correspondence
  * "dual of induced basis", where the dual space incorporates the multiplicities
    which has an intermediate level of component-to-actual-memory-location correspondence
    but natural pairings never involve multiplicities
  * "induced of dual basis", where the dual space doesn't incorporate multiplicities
    which (probably) has the highest component-to-actual-memory-location correspondence
    but natural pairings involve the multiplicities
- the choice of basis will depend on the particular problem being addressed
  * some problems are contraction heavy, in which case "dual of induced basis" could be a good choice
  * some problems are split/bundle heavy, in which case the "induced of dual basis" could be a good choice

implemented features/items:
x operator overloads for expression templates
x trace-type expression templates (where a tensor is contracted with itself, a case which is distinct from * style expression templates)
x prohibiting 3+ summed index expressions
x assignment expression templates
x check assignment for aliasing
x symmetric 2-tensors
x antisymmetric 2-tensors
x custom natural pairing (for non-isometric parameterizations)
x scalar multiplication/division in expression templates
x unary negation in expression templates
x printing expression templates
x down-casting tensors (extracting symmetries out of "broken apart" indexed tensor expressions);
  "bundling" multi-indices into a more-specific "total" index type
x up-casting tensors (breaking symmetries indexed tensor expressions);
  "splitting" a tensor "total" index into a less-specific multi-index
x diagonal 2-tensors
x SVD on 2-tensors, using Eigen
x eigen-decomposition of symmetric 2-tensors, using Eigen
x Eigen interop for using Tensor2_t as Eigen::Map (no memory copy necessary)
x functions for converting Tensor2Antisymmetric_t and Tensor2Symmetric_t to Eigen::Matrix types
x eval method for expression templates (to avoid aliasing problem when assigning)
x no_alias method for avoiding the run-time check against aliased expression template assignments
x Euclidean embeddings for vector and tensor types for when an inner-product-compatible representation is needed.
x Basis identifier for each vector space, giving an additional feature to distinguish vector types with,
  for added correctness, which is particularly useful for the Euclidean embedding stuff.

---------------------------

different multi-indexing schemes
- "split"                 : if t is Tensor2<Tensor2Sym<V>,Tensor2Sym<V> >, then t(P,Q).split(P,i,j),split(Q,k,l)
                            converse to bundle, implementation would be similar.
- "multi-index"           : if s is Tensor2<Tensor5,V>, then s(i,j,k,l,m,T) would be s(multiindex(i,j,k,l,m),T)
                            implementation may be difficult if there are nested multi-indices
- "streaming multi-index" : s/i/j/k/l/m/T or s^i^j^k^l^m^T -- need intermediate "streaming" type
                            left to right, breaking types until there is a match, implementation is probably
                            recursive and relatively easy.  "breaking tensor type boxes apart recursively"
- "barred multi-index"    : s(i|j|k|l|m|T)

handling more general symmetries
- each "linear" symmetry is an inclusion of a linear subspace into a more general type
- any type hierarchy can be encoded this way -- e.g. including Tensor2Simple into Tensor2
- "split" would be used to "use" the inclusions, going to more general types
- "bundle" would be used to "reassert" the symmetries, if you know that the expression has that symmetry.
  would this work for simple tensors?  there would be a nontrivial calculation to assign to a simple tensor.

categorical/conceptual design ideas
- use _c for "category" or "conceptual"
- Field_c<Id>
  * Field_c<Real_c>
  * Field_c<Complex_c>
  * Field_c<F2_c>
  * etc (quaternions could be used, as a skew-field, and maybe SkewField_c<Id> could be a thing
  this should be able to check the validity of a Scalar type (e.g. float, double, int, bool)
  for a field (so Real_c could use float or double, but not int, whereas F2_c could use int but
  not float or double).
  * Module_c, Ring_c (?)
- VectorSpace_c<Field,DIM,Id>
  * Id is just a "name" for the particular type (so that vector spaces can be distinguished
    by more than just their field and dimension), e.g. struct Device3Space { }; or
    struct Screen2Space { };
- TensorProduct_c<VS1,VS2,...,VSN>
  * can only take tensor product of VectorSpace_c types.
- VectorSpaceAndBasis_c<VectorSpace,BasisId>
  * is really just a way to specify a vector space with a choice of basis
- TensorProductAndBases_c<TensorProduct,BasisIdTypeList>
  * a choice of tensor product and basis for each factor
- Vector_i<Scalar,VectorSpaceAndBasis>
  * is the compile-time interface for a type that will be an instance of a vector
- Tensor_i<Scalar,TensorProductAndBasis>
  * is the compile-time interface for a type that will be an instance of a tensor
- Vector_t<Scalar,DIM,VectorSpaceAndBasis = VectorSpaceAndBasis_c<EuclideanInnerProductSpace,StandardBasis> >
  * actual implementation of a strongly typed vector (whose default values make it weakly typed)
- Tensor_t<Scalar,TensorProductAndBases>
  * actual implementation of a strongly typed tensor (no default values, as that wouldn't make sense)

Notes/Reflections on the development of a really really template-heavy library
- Trying to have the compiler enforce the conceptual type system through the C++ type system
  is untenable, as it is too strict and the compile errors it produces are unreadable.
  * A good trick is to write template metafunctions with less constraint and then use static
    asserts to enforce the conceptual type system.  Ted calls this a "honey bucket" for the compiler.
    For example, to enforce that only up/down index pairs can be contracted in a tensor expression,
    write the C++ template code to allow any pairs of indices to be contracted, and then use a
    static assert to enforce the up/down pairing, thereby controlling the situation when there
    is an index mismatch.  The error message produced is then readable and meaningful.
