TENSOR HEAVEN - Tenh (pronounced "tench", similar to hyperbolic tangent tanh)

NOTES
- all library code is in tenh/
  * ideally there will be few/no cpp files
- only the root directory (the directory containing tenh/) should be included, in the same manner as Eigen.
- all test code is in test/ -- these are just informal ad-hoc tests and prototype code, nothing that will be kept around
- the "actual" tensor lib prototype code is in test/contraction_prototype.cpp
- some prototype code for strongly-typed vectors (which distinguish prime/dual spaces and "named" spaces)
  is in test/strongly_typed_vector_prototype.cpp

current goals:
- more frontends for Eigen functionality -- LDLT, QR, linear solve, etc
- strong typing for vectors -- named vector spaces (including "Generic") and prime/dual distinction (including self-dual)
  * default values should be "Generic" vector space ID and self-dual
  * canonical isomorphism for tensor2 -> vector will need to take into account basis
  * canonical isomorphism for vector -> scalar will need to take into account basis (a 1-dimensional vector space always has a
    canonical "unit" basis element which is the real number 1 (?))
  * template <typename Scalar, Uint32 DIM, typename VectorSpaceId, typename BasisId> struct Vector_t (NO default values)
  * VectorSpaceId should have the Dual space type (can specify self-dual here), and a static type_as_string method
  * BasisId should just be a "name" (a type, e.g. struct DiagonalizedBasis)
  * There should be a generic vector space type -- EuclideanSpace (?)
  * There should be a generic basis type -- StandardBasis (?) -- where the inner product is the identity
- column/row/block extraction/addressing
  * something like a(i|c(2)), where i is a TypedIndex_t<Vector,'i'> and c is an Index_t<Vector>
  * will need to somehow distinguish the type of i|c(2) from something like i|j, because a(i|c(2)) is an
    expression template with a particular fixed index plugged in.
- "eval" method on expression templates (which take a list of free indices) which produce an intermediate value
  * something like  (a(i|j)*m(j|k)*a(k|l)).eval(l|i)  (this one makes l the first index, and i the second).
- implement natural pairings as 2-tensors (most are the identity tensor, diagonal, etc)
- this regularizes the implementation and relates to metrics/inner products
  * contractions will "request" the pairing, and if the type exists, the contraction works
    this would allow more flexibility in contractions (e.g. contracting a vector space V with itself via an inner product).
- isometric embedding for various types (e.g. Tensor2Symmetric_t, Tensor2Antisymmetric_t, so that SVD and other
  stuff can be used on them meaningfully, as the SVD and so forth depends on the metric of the relevant space,
  and the way Tensor2Symmetric_t is implemented does not use an isometric representation).
  * the isometric embedding should be the square root of the inner product.

future goals:
- a rigorous test suite, using Lvd test code -- it can handle everything up through seg faults -- and negative compile
  tests implemented at the build level, so that particular intentional compile errors can be verified to work.
- standard in-line linear algebra notation
  * for example, if A is a matrix and v is a vector, "A*v" should be equivalent to "A(i|j)*v(j)", but obviously
    without the need to use an indexed expression.
- optimize evaluation algorithm (ordering operations to do the minimal amount of computation)
- vectorizing as many operations as possible (in cooperation with loop-unrolling?)
- template specializations for particular tensor contractions for speed (using mathematical special cases)
  * for example, an antisymmetric 3x3 2-tensor contracted with a 3-vector is just a cross product
  * a diagonal 2-tensor contracted with a vector is just component-wise scaling
- in strongly typed vector template identifier types, require certain tags (e.g. static member constants)
  in the template parameters -- vector space identifier, vector space basis, etc.
- certain linear algebraic expressions simplify greatly when expressed in a particular basis,
  so having a formal mechanism to work with explicit bases may clarify and simplify some calculations

random TODOs:
- implement [anti]symmetric contiguous_index_to_rowcol_index as a lookup table for speed.
- allow use of same indices across different terms (distinguishing multiplication and addition)
- see if it's possible to do strong range check guarantees for indices (Index_t) -- this would probably
  require a "for each" construct which would best be accomplished with lambda expressions
- the compiler flags don't appear to be doing anything in clang, and possibly gcc.
- apparently "using typename Parent::WhateverType;" works -- change all the dumb typedef inheritance to use this.

implemented features/items:
x operator overloads for expression templates
x trace-type expression templates (where a tensor is contracted with itself, a case which is distinct from * style expression templates)
x prohibiting 3+ summed index expressions
x assignment expression templates
x check assignment for aliasing
x symmetric 2-tensors
x antisymmetric 2-tensors
x custom natural pairing (for non-isometric parameterizations)
x scalar multiplication/division in expression templates
x unary negation in expression templates
x printing expression templates
x down-casting tensors (extracting symmetries out of "broken apart" indexed tensor expressions);
  "bundling" multi-indices into a more-specific "total" index type
x up-casting tensors (breaking symmetries indexed tensor expressions);
  "splitting" a tensor "total" index into a less-specific multi-index
x diagonal 2-tensors
x SVD on 2-tensors, using Eigen
x eigen-decomposition of symmetric 2-tensors, using Eigen
x Eigen interop for using Tensor2_t as Eigen::Map (no memory copy necessary)
x functions for converting Tensor2Antisymmetric_t and Tensor2Symmetric_t to Eigen::Matrix types

---------------------------

different multi-indexing schemes
- "split"                 : if t is Tensor2<Tensor2Sym<V>,Tensor2Sym<V> >, then t(P,Q).split(P,i,j),split(Q,k,l)
                            converse to bundle, implementation would be similar.
- "multi-index"           : if s is Tensor2<Tensor5,V>, then s(i,j,k,l,m,T) would be s(multiindex(i,j,k,l,m),T)
                            implementation may be difficult if there are nested multi-indices
- "streaming multi-index" : s/i/j/k/l/m/T or s^i^j^k^l^m^T -- need intermediate "streaming" type
                            left to right, breaking types until there is a match, implementation is probably
                            recursive and relatively easy.  "breaking tensor type boxes apart recursively"

handling more general symmetries
- each "linear" symmetry is an inclusion of a linear subspace into a more general type
- any type hierarchy can be encoded this way -- e.g. including Tensor2Simple into Tensor2
- "split" would be used to "use" the inclusions, going to more general types
- "bundle" would be used to "reassert" the symmetries, if you know that the expression has that symmetry.
  would this work for simple tensors?  there would be a nontrivial calculation to assign to a simple tensor.

